#!/usr/bin/env bash
#
# CLI options processor has been created with Argbash.
#
# In order to regenerate it, simply copy-paste the whole script to:
# https://argbash.io/generate#generator
#
# Following option definitions were used:
#
# ARG_OPTIONAL_SINGLE([build_dir],[],[build directory])
# ARG_OPTIONAL_SINGLE([configure_opts],[],[options passed to './configure' script])
# ARG_OPTIONAL_BOOLEAN([sudo],[],[whether to use 'sudo make install' or just 'make install'; please note that sudo is still required for writing to '/etc/ld.so.conf.d'.])
# ARG_OPTIONAL_BOOLEAN([git],[],[whether to clone a Git repository instead of downloading a tarball])
# ARG_OPTIONAL_BOOLEAN([verify],[],[whether to verify signature of the downloaded tarball])
# ARG_POSITIONAL_SINGLE([component_name],[component name],[])
# ARG_POSITIONAL_SINGLE([component_ver],[component version],[])
# ARG_HELP([The general script's help msg])
#
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.6.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate

die()
{
	local _ret=$2
	test -n "$_ret" || _ret=1
	test "$_PRINT_HELP" = yes && print_help >&2
	echo "$1" >&2
	exit ${_ret}
}

begins_with_short_option()
{
	local first_option all_short_options
	all_short_options='h'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}



# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_build_dir=
_arg_configure_opts=
_arg_sudo="off"
_arg_git="off"
_arg_verify="off"

print_help ()
{
	printf '%s\n' "The general script's help msg"
	printf 'Usage: %s [--build_dir <arg>] [--configure_opts <arg>] [--(no-)sudo] [--(no-)git] [--(no-)verify] [-h|--help] <component_name> <component_ver>\n' "$0"
	printf '\t%s\n' "<component_name>: component name"
	printf '\t%s\n' "<component_ver>: component version"
	printf '\t%s\n' "--build_dir: build directory (no default)"
	printf '\t%s\n' "--configure_opts: options passed to './configure' script (no default)"
	printf '\t%s\n' "--sudo,--no-sudo: whether to use 'sudo make install' or just 'make install'; please note that sudo is still required for writing to '/etc/ld.so.conf.d'. (off by default)"
	printf '\t%s\n' "--git,--no-git: whether to clone a Git repository instead of downloading a tarball (off by default)"
	printf '\t%s\n' "--verify,--no-verify: whether to verify signature of the downloaded tarball (off by default)"
	printf '\t%s\n' "-h,--help: Prints help"
}

parse_commandline ()
{
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			--build_dir)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_build_dir="$2"
				shift
				;;
			--build_dir=*)
				_arg_build_dir="${_key##--build_dir=}"
				;;
			--configure_opts)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_configure_opts="$2"
				shift
				;;
			--configure_opts=*)
				_arg_configure_opts="${_key##--configure_opts=}"
				;;
			--no-sudo|--sudo)
				_arg_sudo="on"
				test "${1:0:5}" = "--no-" && _arg_sudo="off"
				;;
			--no-git|--git)
				_arg_git="on"
				test "${1:0:5}" = "--no-" && _arg_git="off"
				;;
			--no-verify|--verify)
				_arg_verify="on"
				test "${1:0:5}" = "--no-" && _arg_verify="off"
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_positionals+=("$1")
				;;
		esac
		shift
	done
}


handle_passed_args_count ()
{
	_required_args_string="'component_name' and 'component_ver'"
	test ${#_positionals[@]} -ge 2 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 2 (namely: $_required_args_string), but got only ${#_positionals[@]}." 1
	test ${#_positionals[@]} -le 2 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 2 (namely: $_required_args_string), but got ${#_positionals[@]} (the last one was: '${_positionals[*]: -1}')." 1
}

assign_positional_args ()
{
	_positional_names=('_arg_component_name' '_arg_component_ver' )

	for (( ii = 0; ii < ${#_positionals[@]}; ii++))
	do
		eval "${_positional_names[ii]}=\${_positionals[ii]}" || die "Error during argument parsing, possibly an Argbash bug." 1
	done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash
#
# ========================================
# !!!  END OF ARGBASH GENERATED LOGIC  !!!
# ========================================
#

set -e # Early exit if any command returns non-zero status code
set -x # Print every command to STDOUT

# Consults https://versions.gnupg.org/swdb.lst and assigns the most recent
# version of component ${_arg_component_name} to ${_arg_component_ver} variable.
determine_latest_version()
{
	local _grep_expression="${_arg_component_name}_ver"
	_arg_component_ver=`curl "https://versions.gnupg.org/swdb.lst" | grep "${_grep_expression}" | cut -d " " -f 2`
}

fetch_source()
{
	if [[ "${_arg_git}" = "on" ]]; then
		fetch_from_git
	else
		fetch_release
	fi
}

fetch_release()
{
	local _tarball_file_name="${_arg_component_name}-${_arg_component_ver}.tar.bz2"
	local _tarball_url="https://gnupg.org/ftp/gcrypt/${_arg_component_name}/${_tarball_file_name}"
	curl ${_tarball_url} --remote-name --retry 5
	tar -xjf ${_tarball_file_name}
	rm ${_tarball_file_name}
	set_component_build_dir "${_arg_component_name}-${_arg_component_ver}"
}

fetch_from_git()
{
	local _git_url="git://git.gnupg.org/${_arg_component_name}"
	set_component_build_dir "${_arg_component_name}-git-${_arg_component_ver}"

	if [ ! -d "${_component_build_dir}" ]; then
		git clone ${_git_url} "${_component_build_dir}"
	else
		pushd "${_component_build_dir}"
		git fetch # need to fetch prior checkout, ref may be nonexistent locally
		popd
	fi

	pushd "${_component_build_dir}"
	git checkout ${_arg_component_ver}
	git pull # in case of outdated local branch
	popd
}

build_and_install()
{
	pushd "${_component_build_dir}"
	./configure ${_arg_configure_opts}
	make > /dev/null
	sudo make install > /dev/null
	popd
}

set_component_build_dir()
{
	_component_build_dir=$1
}


###

if [[ "${_arg_component_ver}" =~ ^latest ]]; then
	determine_latest_version
fi

mkdir -p ${_arg_build_dir}
pushd ${_arg_build_dir}
fetch_source
build_and_install
popd # _arg_build_dir

if [[ "${_arg_component_name}" =~ ^gnupg ]]; then
	sudo tee -a /etc/ld.so.conf.d/gpg2.conf <<<"/usr/local/lib"
	sudo ldconfig -v
fi
# ] <-- needed because of Argbash
